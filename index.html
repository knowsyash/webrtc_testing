<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Audio Call App</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      background: #0a1612;
      background-image: 
        radial-gradient(at 0% 0%, rgba(16, 185, 129, 0.12) 0px, transparent 50%),
        radial-gradient(at 100% 0%, rgba(148, 163, 184, 0.1) 0px, transparent 50%),
        radial-gradient(at 100% 100%, rgba(5, 150, 105, 0.08) 0px, transparent 50%);
      min-height: 100vh;
      padding: 20px;
      -webkit-text-size-adjust: 100%;
      color: #e2e8f0;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(15, 25, 23, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 24px;
      box-shadow: 
        0 0 0 1px rgba(148, 163, 184, 0.2),
        0 20px 60px rgba(0, 0, 0, 0.6),
        inset 0 1px 0 rgba(148, 163, 184, 0.1);
      overflow: hidden;
      border: 1px solid rgba(148, 163, 184, 0.15);
    }

    .header {
      background: linear-gradient(135deg, rgba(5, 150, 105, 0.3) 0%, rgba(6, 95, 70, 0.3) 100%);
      border-bottom: 2px solid rgba(148, 163, 184, 0.25);
      color: white;
      padding: 48px 40px;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent,
        rgba(203, 213, 225, 0.6),
        transparent
      );
    }

    .header h1 {
      font-size: 2.75rem;
      font-weight: 700;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 18px;
      background: linear-gradient(135deg, #94a3b8 0%, #e2e8f0 40%, #10b981 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -0.02em;
    }

    .header p {
      font-size: 1.15rem;
      opacity: 0.92;
      color: #cbd5e1;
      font-weight: 400;
      line-height: 1.6;
    }

    .content {
      padding: 48px 44px;
    }

    .video-container {
      display: none;
      gap: 20px;
      margin: 30px 0;
      flex-wrap: wrap;
      width: 100%;
    }

    .video-wrapper {
      flex: 1;
      min-width: min(280px, 100%);
      max-width: 100%;
      background: linear-gradient(145deg, rgba(203, 213, 225, 0.15) 0%, rgba(148, 163, 184, 0.15) 100%);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 0 0 1px rgba(203, 213, 225, 0.3), 0 8px 24px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 2px solid rgba(203, 213, 225, 0.2);
    }

    .video-wrapper:hover {
      transform: translateY(-8px);
      box-shadow: 0 0 0 1px rgba(226, 232, 240, 0.5), 0 20px 40px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15), 0 0 30px rgba(203, 213, 225, 0.2);
      border-color: rgba(226, 232, 240, 0.4);
    }

    .video-wrapper h3 {
      text-align: center;
      background: linear-gradient(135deg, rgba(203, 213, 225, 0.25) 0%, rgba(148, 163, 184, 0.25) 100%);
      color: #e2e8f0;
      padding: 16px;
      font-size: 1.1rem;
      font-weight: 600;
      border-bottom: 2px solid rgba(203, 213, 225, 0.3);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
      position: relative;
    }

    .video-wrapper h3::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent,
        rgba(226, 232, 240, 0.5),
        transparent
      );
    }

    video {
      width: 100%;
      height: 320px;
      background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%);
      object-fit: cover;
      -webkit-playsinline: true;
      display: block;
      border: 2px solid rgba(203, 213, 225, 0.1);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .card {
      background: rgba(20, 35, 30, 0.6);
      backdrop-filter: blur(15px);
      border-radius: 20px;
      padding: 32px;
      margin: 24px 0;
      box-shadow: 
        0 0 0 1px rgba(148, 163, 184, 0.2), 
        0 10px 30px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(148, 163, 184, 0.2);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .card:hover {
      border-color: rgba(16, 185, 129, 0.4);
      box-shadow: 
        0 0 0 1px rgba(16, 185, 129, 0.4), 
        0 15px 40px rgba(0, 0, 0, 0.5), 
        0 0 30px rgba(16, 185, 129, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.08);
      transform: translateY(-2px);
    }

    .card h3 {
      color: #f8fafc;
      margin-bottom: 24px;
      font-size: 1.4rem;
      font-weight: 600;
      letter-spacing: -0.03em;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    input[type="text"] {
      padding: 18px 24px;
      font-size: 1.05rem;
      background: rgba(10, 20, 18, 0.7);
      border: 2px solid rgba(148, 163, 184, 0.25);
      border-radius: 14px;
      outline: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      width: 100%;
      max-width: 360px;
      color: #f1f5f9;
      font-weight: 500;
      box-shadow: 
        inset 0 2px 4px rgba(0, 0, 0, 0.2),
        0 1px 2px rgba(0, 0, 0, 0.1);
    }

    input[type="text"]::placeholder {
      color: #94a3b8;
      font-weight: 400;
    }

    input[type="text"]:focus {
      border-color: #10b981;
      box-shadow: 
        0 0 0 4px rgba(16, 185, 129, 0.15),
        0 0 25px rgba(16, 185, 129, 0.2),
        inset 0 2px 4px rgba(0, 0, 0, 0.1);
      background: rgba(10, 20, 18, 0.9);
      transform: translateY(-1px);
    }

    button {
      padding: 18px 36px;
      font-size: 1.05rem;
      font-weight: 600;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      -webkit-appearance: none;
      appearance: none;
      position: relative;
      overflow: hidden;
      color: #ffffff;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      letter-spacing: 0.02em;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover {
      transform: translateY(-3px);
    }

    button:active {
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none !important;
      filter: grayscale(0.5);
    }

    /* Button color variants */
    .btn-primary {
      background: linear-gradient(135deg, #047857 0%, #065f46 100%);
      box-shadow: 
        0 4px 20px rgba(4, 120, 87, 0.45), 
        inset 0 1px 0 rgba(255, 255, 255, 0.15),
        0 0 0 1px rgba(16, 185, 129, 0.2);
      border: 1px solid rgba(16, 185, 129, 0.3);
    }

    .btn-primary:hover {
      background: linear-gradient(135deg, #065f46 0%, #064e3b 100%);
      box-shadow: 
        0 8px 30px rgba(4, 120, 87, 0.6), 
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 30px rgba(16, 185, 129, 0.3);
      border-color: rgba(16, 185, 129, 0.5);
    }

    .btn-success {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      box-shadow: 
        0 4px 20px rgba(16, 185, 129, 0.5), 
        inset 0 1px 0 rgba(255, 255, 255, 0.15),
        0 0 0 1px rgba(52, 211, 153, 0.3);
      border: 1px solid rgba(52, 211, 153, 0.4);
    }

    .btn-success:hover {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      box-shadow: 
        0 8px 35px rgba(16, 185, 129, 0.65), 
        inset 0 1px 0 rgba(255, 255, 255, 0.2), 
        0 0 35px rgba(16, 185, 129, 0.4);
      border-color: rgba(52, 211, 153, 0.6);
    }

    .btn-warning {
      background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
      box-shadow: 
        0 4px 20px rgba(217, 119, 6, 0.45), 
        inset 0 1px 0 rgba(255, 255, 255, 0.15),
        0 0 0 1px rgba(251, 146, 60, 0.2);
      border: 1px solid rgba(251, 146, 60, 0.3);
    }

    .btn-warning:hover {
      background: linear-gradient(135deg, #b45309 0%, #92400e 100%);
      box-shadow: 
        0 8px 30px rgba(217, 119, 6, 0.6), 
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 30px rgba(251, 146, 60, 0.3);
      border-color: rgba(251, 146, 60, 0.5);
    }

    .btn-danger {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
      box-shadow: 
        0 4px 20px rgba(220, 38, 38, 0.45), 
        inset 0 1px 0 rgba(255, 255, 255, 0.15),
        0 0 0 1px rgba(248, 113, 113, 0.2);
      border: 1px solid rgba(248, 113, 113, 0.3);
    }

    .btn-danger:hover {
      background: linear-gradient(135deg, #b91c1c 0%, #991b1b 100%);
      box-shadow: 
        0 8px 30px rgba(220, 38, 38, 0.6), 
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 30px rgba(248, 113, 113, 0.3);
      border-color: rgba(248, 113, 113, 0.5);
    }

    .btn-info {
      background: linear-gradient(135deg, #64748b 0%, #475569 100%);
      box-shadow: 
        0 4px 20px rgba(100, 116, 139, 0.45), 
        inset 0 1px 0 rgba(255, 255, 255, 0.15),
        0 0 0 1px rgba(148, 163, 184, 0.3);
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .btn-info:hover {
      background: linear-gradient(135deg, #475569 0%, #334155 100%);
      box-shadow: 
        0 8px 30px rgba(100, 116, 139, 0.6), 
        inset 0 1px 0 rgba(255, 255, 255, 0.2), 
        0 0 30px rgba(148, 163, 184, 0.4);
      border-color: rgba(148, 163, 184, 0.6);
    }

    /* Touch-friendly improvements */
    @media (hover: none) and (pointer: coarse) {
      button {
        min-height: 48px;
        padding: 16px 28px;
      }

      input[type="text"] {
        min-height: 48px;
        font-size: 16px;
      }

      .video-wrapper:hover {
        transform: none;
      }

      button:hover {
        transform: none;
      }

      button:active {
        transform: scale(0.98);
      }
    }

    .flex-row {
      display: flex;
      align-items: center;
      gap: 18px;
      flex-wrap: wrap;
    }

    /* Improved responsive utilities */
    .text-center {
      text-align: center;
    }

    .w-full {
      width: 100%;
    }

    /* Ensure container never exceeds viewport */
    .container {
      max-width: min(1200px, 100vw - 40px);
    }

    .alert {
      padding: 24px 28px;
      border-radius: 16px;
      margin: 24px 0;
      border-left: 5px solid;
      backdrop-filter: blur(12px);
      overflow-wrap: break-word;
      word-wrap: break-word;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .alert h4 {
      margin-bottom: 14px;
      font-weight: 600;
      color: inherit;
      filter: brightness(1.2);
      font-size: 1.15rem;
    }

    .alert ul {
      margin-left: 24px;
      margin-top: 12px;
      color: #e2e8f0;
      line-height: 1.7;
    }

    .alert li {
      margin: 8px 0;
    }

    /* Alert variants */
    .alert-info {
      background: rgba(100, 116, 139, 0.15);
      border-color: #64748b;
      color: #cbd5e1;
    }

    .alert-warning {
      background: rgba(217, 119, 6, 0.15);
      border-color: #d97706;
      color: #fcd34d;
    }

    .alert-success {
      background: rgba(16, 185, 129, 0.15);
      border-color: #10b981;
      color: #86efac;
    }

    .call-id-display {
      background: rgba(10, 20, 18, 0.7);
      padding: 28px 32px;
      border-radius: 16px;
      border: 2px dashed rgba(148, 163, 184, 0.45);
      text-align: center;
      box-shadow: 
        inset 0 2px 10px rgba(0, 0, 0, 0.4),
        0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .call-id-display input {
      font-size: 2.2rem;
      font-weight: 700;
      text-align: center;
      border: none;
      background: transparent;
      color: #a8b8c8;
      max-width: 100%;
      text-shadow: 0 0 35px rgba(148, 163, 184, 0.6);
      letter-spacing: 0.08em;
    }

    .call-controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 40px 0;
      flex-wrap: wrap;
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }

    .modal-content {
      background: rgba(20, 35, 30, 0.95);
      backdrop-filter: blur(20px);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.2), 0 20px 60px rgba(0, 0, 0, 0.6);
      max-width: 500px;
      width: 90%;
      animation: slideIn 0.3s ease;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    @keyframes slideIn {
      from {
        transform: translateY(-50px) scale(0.95);
        opacity: 0;
      }
      to {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }

    .modal-content h2 {
      color: #fca5a5;
      margin-bottom: 20px;
      font-size: 2rem;
      font-weight: 700;
      text-shadow: 0 2px 10px rgba(252, 165, 165, 0.3);
    }

    .modal-content p {
      font-size: 1.2rem;
      margin: 20px 0;
      color: #e2e8f0;
      font-weight: 400;
    }

    /* Tablet landscape and smaller desktops */
    @media (max-width: 1024px) {
      .container {
        margin: 10px;
      }

      .header {
        padding: 30px 20px;
      }

      .header h1 {
        font-size: 2.2rem;
      }

      .content {
        padding: 30px 25px;
      }

      video {
        height: 280px;
      }
    }

    /* Tablet portrait */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .container {
        border-radius: 16px;
      }

      .header {
        padding: 25px 20px;
      }

      .header h1 {
        font-size: 1.8rem;
        gap: 10px;
      }

      .header h1 span {
        font-size: 1.5rem;
      }

      .header p {
        font-size: 0.95rem;
      }

      .content {
        padding: 20px;
      }

      .video-container {
        flex-direction: column;
        gap: 15px;
        margin: 20px 0;
      }

      .video-wrapper {
        min-width: 100%;
      }

      video {
        height: 250px;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
      }

      .card {
        padding: 20px;
        margin: 15px 0;
      }

      .card h3 {
        font-size: 1.15rem;
      }

      input[type="text"] {
        width: 100%;
        max-width: 100%;
        min-height: 48px;
        font-size: 1rem;
      }

      button {
        width: 100%;
        max-width: 100%;
        min-height: 48px;
        padding: 14px 24px;
        font-size: 0.95rem;
      }

      .flex-row {
        flex-direction: column;
        width: 100%;
        gap: 12px;
      }

      .call-id-display {
        padding: 20px 15px;
      }

      .call-id-display input {
        font-size: 1.5rem;
      }

      .call-controls {
        gap: 12px;
        margin: 20px 0;
      }

      .alert {
        padding: 16px;
        font-size: 0.9rem;
      }

      .alert h4 {
        font-size: 1rem;
      }

      .modal-content {
        padding: 30px 20px;
        width: 95%;
      }

      .modal-content h2 {
        font-size: 1.6rem;
      }

      .modal-content p {
        font-size: 1rem;
      }
    }

    /* Mobile landscape */
    @media (max-width: 640px) and (orientation: landscape) {
      .header {
        padding: 20px;
      }

      .header h1 {
        font-size: 1.5rem;
      }

      .header p {
        font-size: 0.85rem;
      }

      .content {
        padding: 15px;
      }

      video {
        height: 200px;
      }

      .card {
        padding: 15px;
      }
    }

    /* Small mobile devices */
    @media (max-width: 480px) {
      body {
        padding: 5px;
      }

      .container {
        border-radius: 12px;
      }

      .header {
        padding: 20px 15px;
      }

      .header h1 {
        font-size: 1.5rem;
        flex-direction: column;
        gap: 8px;
      }

      .header h1 span {
        font-size: 1.2rem;
      }

      .header p {
        font-size: 0.85rem;
      }

      .content {
        padding: 15px;
      }

      .video-wrapper h3 {
        font-size: 0.95rem;
        padding: 12px;
      }

      video {
        height: 220px;
      }

      .card {
        padding: 16px;
        border-radius: 12px;
      }

      .card h3 {
        font-size: 1.05rem;
        margin-bottom: 12px;
      }

      input[type="text"] {
        padding: 14px 16px;
        font-size: 0.95rem;
        border-radius: 10px;
      }

      button {
        padding: 14px 20px;
        font-size: 0.9rem;
        border-radius: 10px;
      }

      .call-id-display {
        padding: 16px 12px;
      }

      .call-id-display input {
        font-size: 1.2rem;
      }

      .alert {
        padding: 14px;
        font-size: 0.85rem;
        border-radius: 10px;
      }

      .alert h4 {
        font-size: 0.95rem;
        margin-bottom: 8px;
      }

      .alert ul {
        margin-left: 16px;
        font-size: 0.8rem;
      }

      .alert li {
        margin: 4px 0;
      }

      .modal-content {
        padding: 25px 15px;
        border-radius: 16px;
      }

      .modal-content h2 {
        font-size: 1.4rem;
        margin-bottom: 15px;
      }

      .modal-content p {
        font-size: 0.9rem;
        margin: 15px 0;
      }
    }

    /* Extra small devices (very small phones) */
    @media (max-width: 360px) {
      .header h1 {
        font-size: 1.3rem;
      }

      .header h1 span {
        font-size: 1rem;
      }

      .header p {
        font-size: 0.8rem;
      }

      video {
        height: 180px;
      }

      .card h3 {
        font-size: 1rem;
      }

      button {
        padding: 12px 16px;
        font-size: 0.85rem;
      }

      .call-id-display input {
        font-size: 1rem;
      }

      .modal-content h2 {
        font-size: 1.2rem;
      }
    }

    /* Print styles */
    @media print {
      body {
        background: white;
      }

      .container {
        box-shadow: none;
        border: 1px solid #000;
      }

      button,
      video,
      .alert {
        display: none;
      }
    }

    /* Android-specific optimizations */
    @media screen and (-webkit-min-device-pixel-ratio: 1) {
      video {
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        will-change: transform;
      }
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 10px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(15, 23, 42, 0.5);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.5);
      border-radius: 5px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(99, 102, 241, 0.7);
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>
        <span>üìû</span>
        WebRTC Video Call
        <span>üé•</span>
      </h1>
      <p>Connect with anyone, anywhere - Crystal clear audio and video calls</p>
    </div>

    <div class="content">
      <!-- Mobile Warning -->
      <div id="mobileWarning" class="alert alert-info" style="display: none;">
        <h4>üì± Mobile Device Detected</h4>
        <p>For best results on Android/Mobile:</p>
        <ul>
          <li><strong>MUST use HTTPS:</strong> Deploy to GitHub Pages (https://yourname.github.io/...)</li>
          <li><strong>Allow permissions:</strong> Camera AND microphone when prompted</li>
          <li><strong>Use Chrome browser</strong> for best compatibility</li>
          <li><strong>Close other camera apps</strong> before using this</li>
          <li>If video is black, refresh the page and try again</li>
          <li>Keep your device charged (camera uses battery)</li>
        </ul>
      </div>

      <!-- Video Container -->
      <div class="video-container">
        <div class="video-wrapper">
          <h3>üë§ Your Camera (Local)</h3>
          <video id="localVideo" autoplay muted playsinline webkit-playsinline controls="false"></video>
        </div>
        <div class="video-wrapper">
          <h3>üë• Remote Camera (Other Person)</h3>
          <video id="remoteVideo" autoplay playsinline webkit-playsinline controls="false"></video>
        </div>
      </div>

      <!-- Create Call Section -->
      <div class="card">
        <h3>üöÄ Start a New Call</h3>
        <button id="createCall" class="btn-success">
          ‚ú® Create New Call
        </button>
      </div>

      <!-- Call ID Display -->
      <div id="callIdSection" class="card" style="display: none;">
        <h3>üîë Your Call ID</h3>
        <div class="call-id-display">
          <input type="text" id="generatedCallId" readonly>
        </div>
        <div class="flex-row" style="margin-top: 20px; justify-content: center;">
          <button id="copyCallId" class="btn-info">
            üìã Copy ID
          </button>
        </div>
        <p style="color: #666; margin-top: 15px; text-align: center;">
          üì§ Share this ID with the person you want to call
        </p>
      </div>

      <!-- Join Call Section -->
      <div class="card">
        <h3>üîó Join an Existing Call</h3>
        <div class="flex-row">
          <input type="text" id="callIdInput" placeholder="Enter Call ID">
          <button id="joinCall" class="btn-warning">
            üö™ Join Call
          </button>
        </div>
      </div>

      <!-- Call Controls -->
      <div id="endCallSection" class="call-controls" style="display: none;">
        <button id="toggleVideo" class="btn-info">
          üìπ Enable Video
        </button>
        <button id="endCall" class="btn-danger">
          ‚ö´ End Call
        </button>
      </div>

      <!-- Status Display -->
      <div id="statusDisplay" class="alert alert-success" style="display: none;">
        <p id="statusText"></p>
      </div>

      <!-- Permission Help -->
      <div id="permissionHelp" class="alert alert-warning" style="display: none;">
        <h4>üìπ Camera & Microphone Permissions Required</h4>
        <p>To use video calling, you need to allow camera and microphone access:</p>
        <ol>
          <li>When prompted, click <strong>"Allow"</strong> (not "Block" or "Deny")</li>
          <li>If you see a camera icon in your browser's address bar, click it and select "Allow"</li>
          <li>If you accidentally blocked access, refresh the page and try again</li>
        </ol>
        <div class="flex-row" style="margin-top: 15px;">
          <button id="requestPermissionsBtn" class="btn-danger">
            üìπ Allow Camera & Microphone
          </button>
          <button onclick="document.getElementById('permissionHelp').style.display='none'" class="btn-info">
            Got it!
          </button>
          <button onclick="window.location.reload()" class="btn-success">
            üîÑ Refresh Page
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Call Ended Modal -->
  <div id="callEndedModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <h2>üìû Call Ended</h2>
      <p id="callEndedMessage">The call has ended.</p>
      <button onclick="closeCallEndedModal()" class="btn-success">
        ‚úÖ OK
      </button>
    </div>
  </div>

  <script type="module">
    // Mobile device detection and warning
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);

    if (isMobile) {
      document.getElementById('mobileWarning').style.display = 'block';
      console.log('Mobile device detected:', { isMobile, isAndroid });
    }

    // Android-specific checks
    if (isAndroid) {
      console.log('Android device detected - applying Android optimizations');

      // Check for HTTPS on Android
      if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        const httpsWarning = document.createElement('div');
        httpsWarning.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; background: #f44336; color: white; padding: 10px; text-align: center; z-index: 1000;';
        httpsWarning.innerHTML = '‚ö†Ô∏è HTTPS Required on Android! Please use GitHub Pages (https://yourname.github.io/...)';
        document.body.insertBefore(httpsWarning, document.body.firstChild);
      }

      // Android performance optimizations
      document.addEventListener('DOMContentLoaded', () => {
        // Disable text selection for better mobile experience
        document.body.style.webkitUserSelect = 'none';
        document.body.style.webkitTouchCallout = 'none';
      });
    }

    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
    import { getDatabase, ref, set, get, onChildAdded, child } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js";

    // ----- Firebase config -----
    const firebaseConfig = {
      apiKey: "AIzaSyDGJvWk6h7JFtuqdsM4RNGJwiQj_ZUz9R8",
      authDomain: "rtc-project-sih.firebaseapp.com",
      databaseURL: "https://rtc-project-sih-default-rtdb.firebaseio.com/",
      projectId: "rtc-project-sih",
      storageBucket: "rtc-project-sih.appspot.com",
      messagingSenderId: "21024104436",
      appId: "1:21024104436:web:23cf8fe41b750d118ba3a1"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const createBtn = document.getElementById("createCall");
    const joinBtn = document.getElementById("joinCall");
    const callIdInput = document.getElementById("callIdInput");
    const callIdDisplay = document.getElementById("callIdDisplay");
    const callIdSection = document.getElementById("callIdSection");
    const generatedCallId = document.getElementById("generatedCallId");
    const copyCallIdBtn = document.getElementById("copyCallId");
    const statusDisplay = document.getElementById("statusDisplay");
    const statusText = document.getElementById("statusText");
    const endCallBtn = document.getElementById("endCall");
    const endCallSection = document.getElementById("endCallSection");
    const toggleVideoBtn = document.getElementById("toggleVideo");
    const videoContainer = document.querySelector(".video-container");

    let pc;
    let localStream;
    let currentCallId;
    let permissionRequestInProgress = false;
    let videoEnabled = false; // Track video state

    const servers = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "turn:turn.anyfirewall.com:443?transport=tcp", username: "webrtc", credential: "webrtc" }
      ]
    };

    // Manual permission request function for user interaction
    async function requestPermissionsManually() {
      if (permissionRequestInProgress) {
        console.log('Permission request already in progress');
        return;
      }

      try {
        permissionRequestInProgress = true;
        document.getElementById('requestPermissionsBtn').textContent = '‚è≥ Requesting...';
        document.getElementById('requestPermissionsBtn').disabled = true;

        // Simple request to avoid Android permission loops
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

        // Store the stream globally if successful
        localStream = stream;

        // Store successful permission
        const isAndroid = /Android/i.test(navigator.userAgent);
        if (isAndroid) {
          localStorage.setItem('webrtc_permissions_granted', Date.now().toString());
        }

        console.log('Manual permission request successful');
        document.getElementById('permissionHelp').style.display = 'none';
        showStatus('‚úÖ Camera and microphone access granted! You can now create or join calls.', false);

        return true;
      } catch (error) {
        console.error('Manual permission request failed:', error);

        let errorMsg = 'Permission request failed. ';
        if (error.name === 'NotAllowedError') {
          errorMsg += 'Please click "Allow" when prompted, or check your browser settings.';
        }

        alert(errorMsg);
        document.getElementById('requestPermissionsBtn').textContent = 'üìπ Allow Camera & Microphone';
        document.getElementById('requestPermissionsBtn').disabled = false;

        return false;
      } finally {
        permissionRequestInProgress = false;
      }
    }

    async function checkPermissions() {
      // Check if Permissions API is available
      if ('permissions' in navigator) {
        try {
          const cameraPermission = await navigator.permissions.query({ name: 'camera' });
          const microphonePermission = await navigator.permissions.query({ name: 'microphone' });

          console.log('Camera permission state:', cameraPermission.state);
          console.log('Microphone permission state:', microphonePermission.state);

          return {
            camera: cameraPermission.state,
            microphone: microphonePermission.state
          };
        } catch (error) {
          console.log('Permissions API not fully supported:', error);
          return null;
        }
      }
      return null;
    }

    async function initMedia() {
      try {
        // Check if we already have a stream from manual permission request
        if (localStream && localStream.getTracks().length > 0) {
          console.log('Using existing stream from manual permission request');

          // Set up local video
          localVideo.srcObject = localStream;
          localVideo.setAttribute('muted', 'true');
          localVideo.setAttribute('playsinline', 'true');
          localVideo.setAttribute('webkit-playsinline', 'true');
          localVideo.setAttribute('autoplay', 'true');

          await localVideo.play().catch(e => console.log('Local video play failed:', e));

          showStatus("Using existing camera and microphone access!");
          return;
        }

        // Check HTTPS requirement for mobile
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
          throw new Error('HTTPS is required for camera/microphone access on mobile devices. Please use GitHub Pages or HTTPS.');
        }

        // Check if getUserMedia is supported
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('Browser does not support camera/microphone access');
        }

        // Check existing permissions first
        const permissionStates = await checkPermissions();
        if (permissionStates) {
          if (permissionStates.camera === 'denied' || permissionStates.microphone === 'denied') {
            throw new Error('Camera or microphone access is permanently denied. Please reset permissions in browser settings.');
          }

          if (permissionStates.camera === 'granted' && permissionStates.microphone === 'granted') {
            console.log('Permissions already granted, proceeding...');
          }
        }

        showStatus("Please allow camera and microphone access when prompted...");

        // Detect device type
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);

        console.log('Device detection:', { isMobile, isAndroid });

        // For Android, use very simple constraints first
        let constraints;
        if (isAndroid) {
          // Simplified constraints for Android to avoid permission loops
          constraints = {
            video: true,
            audio: true
          };
        } else if (isMobile) {
          constraints = {
            video: {
              facingMode: 'user'
            },
            audio: true
          };
        } else {
          // Desktop constraints
          constraints = {
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 }
            },
            audio: true
          };
        }

        // Store successful permission for future reference
        const permissionKey = 'webrtc_permissions_granted';

        // Single request approach to avoid repeated permission prompts on Android
        try {
          console.log('Requesting media with constraints:', constraints);
          localStream = await navigator.mediaDevices.getUserMedia(constraints);

          // Store successful permission
          if (isAndroid) {
            localStorage.setItem(permissionKey, Date.now().toString());
          }

          console.log('Media access successful');
        } catch (mediaError) {
          console.log('Media request failed:', mediaError);

          // Only try basic fallback for Android if the error is constraint-related
          if (isAndroid && (mediaError.name === 'OverconstrainedError' || mediaError.name === 'ConstraintNotSatisfiedError')) {
            console.log('Trying basic Android fallback...');
            try {
              localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
              localStorage.setItem(permissionKey, Date.now().toString());
              console.log('Android fallback successful');
            } catch (fallbackError) {
              console.log('Android fallback failed:', fallbackError);
              throw fallbackError;
            }
          } else {
            throw mediaError;
          }
        }

        // Set up local video with Android-specific handling
        localVideo.srcObject = localStream;

        // Start with video disabled (audio-only mode)
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = false; // Start with video disabled
          videoEnabled = false;
        }

        // Android-specific video attributes
        localVideo.setAttribute('muted', 'true');
        localVideo.setAttribute('playsinline', 'true');
        localVideo.setAttribute('webkit-playsinline', 'true');
        localVideo.setAttribute('autoplay', 'true');

        if (isAndroid) {
          // Additional Android optimizations
          localVideo.setAttribute('preload', 'metadata');
          localVideo.volume = 0; // Ensure muted for autoplay
        }

        // Force video play with multiple attempts
        let playAttempts = 0;
        const maxPlayAttempts = 3;

        const attemptPlay = async () => {
          try {
            await localVideo.play();
            console.log(`Local video play successful on attempt ${playAttempts + 1}`);
            return true;
          } catch (playError) {
            playAttempts++;
            console.log(`Play attempt ${playAttempts} failed:`, playError);

            if (playAttempts < maxPlayAttempts) {
              // Wait and try again
              await new Promise(resolve => setTimeout(resolve, 500));
              return attemptPlay();
            } else {
              console.log('All play attempts failed, but continuing...');
              return false;
            }
          }
        };

        await attemptPlay();

        console.log('Media initialized successfully');
        console.log('Local stream tracks:', localStream.getTracks().map(t => `${t.kind}: ${t.enabled} (${t.readyState})`));
        console.log('Video constraints used:', localStream.getVideoTracks()[0]?.getSettings());
        showStatus("Camera and microphone access granted!");

      } catch (error) {
        console.error('Error accessing media devices:', error);

        let errorMessage = "Error accessing camera/microphone. ";

        if (error.message.includes('HTTPS')) {
          errorMessage = "‚ùå HTTPS Required: Please use GitHub Pages (https://yourname.github.io/...) to access camera on mobile.";
        } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
          errorMessage += "Please click 'Allow' when prompted for camera/microphone permissions. On Android, make sure to allow both camera and microphone.";
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
          errorMessage += "No camera or microphone found. Please check your Android device settings.";
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
          errorMessage += "Camera/microphone is being used by another app. Please close other camera apps and try again.";
        } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
          errorMessage += "Camera settings not supported. Trying basic camera access...";
        } else {
          errorMessage += "Please ensure permissions are granted and try again.";
        }

        showStatus(errorMessage, true);
        alert(errorMessage);
        throw error;
      }
    }

    function generateCallId() {
      // Generate a more user-friendly 6-character ID
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      let id = "";
      for (let i = 0; i < 6; i++) {
        id += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return id;
    }

    function showStatus(message, isError = false) {
      statusText.textContent = message;
      statusDisplay.style.display = 'block';
      statusDisplay.style.background = isError ? '#ffe8e8' : '#e8f5e8';
      console.log(message);
    }

    function hideStatus() {
      statusDisplay.style.display = 'none';
    }

    // Function to close the call ended modal
    function closeCallEndedModal() {
      document.getElementById('callEndedModal').style.display = 'none';
    }

    // Make closeCallEndedModal globally accessible
    window.closeCallEndedModal = closeCallEndedModal;

    // Function to show call ended modal
    function showCallEndedModal(isInitiator = false) {
      const modal = document.getElementById('callEndedModal');
      const messageElement = document.getElementById('callEndedMessage');

      if (isInitiator) {
        messageElement.textContent = 'You have successfully ended the call.';
      } else {
        messageElement.textContent = 'Call Ended';
      }

      modal.style.display = 'flex';
    }

    // Debug function to check video status
    function checkVideoStatus() {
      console.log('=== VIDEO STATUS CHECK ===');
      console.log('Local video element:', localVideo);
      console.log('Local video srcObject:', localVideo.srcObject);
      console.log('Local video readyState:', localVideo.readyState);
      console.log('Local video paused:', localVideo.paused);
      console.log('Remote video element:', remoteVideo);
      console.log('Remote video srcObject:', remoteVideo.srcObject);
      console.log('Remote video readyState:', remoteVideo.readyState);
      console.log('Remote video paused:', remoteVideo.paused);
      if (localStream) {
        console.log('Local stream tracks:', localStream.getTracks().map(t => `${t.kind}: ${t.enabled}`));
      }
      console.log('========================');
    }

    // Function to end the call
    function endCall() {
      console.log('Ending call...');

      try {
        // Send end call signal to Firebase to notify the other participant
        if (currentCallId) {
          const endCallSignal = {
            type: 'endCall',
            timestamp: Date.now()
          };
          set(ref(db, `calls/${currentCallId}/signals/endCall`), endCallSignal)
            .catch(error => console.error('Error sending end call signal:', error));
        }

        // Stop all local stream tracks
        if (localStream) {
          localStream.getTracks().forEach(track => {
            track.stop();
            console.log('Stopped local track:', track.kind);
          });
          localStream = null;
        }

        // Close peer connection
        if (pc) {
          pc.close();
          console.log('Peer connection closed');
          pc = null;
        }

        // Clear video elements
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;

        // Reset UI state
        endCallSection.style.display = 'none';
        callIdSection.style.display = 'none';

        // Hide video container (keep audio call appearance)
        videoContainer.style.display = 'none';
        videoEnabled = false;
        toggleVideoBtn.textContent = 'üìπ Enable Video';
        toggleVideoBtn.style.background = '#2196F3';

        // Clear call ID
        callIdInput.value = '';
        generatedCallId.value = '';
        currentCallId = null;

        // Show "Call ended" modal for the person who ended the call as well
        setTimeout(() => {
          showCallEndedModal(true); // true indicates this person initiated the end call
        }, 500);

        console.log('Call ended and UI reset');
      } catch (error) {
        console.error('Error ending call:', error);
        showStatus('Error ending call', true);
      }
    }

    // Function to end call locally without sending signal (used when receiving end call signal)
    function endCallLocally() {
      console.log('Ending call locally (received end signal)...');

      try {
        // Stop all local stream tracks
        if (localStream) {
          localStream.getTracks().forEach(track => {
            track.stop();
            console.log('Stopped local track:', track.kind);
          });
          localStream = null;
        }

        // Close peer connection
        if (pc) {
          pc.close();
          console.log('Peer connection closed');
          pc = null;
        }

        // Clear video elements
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;

        // Reset UI state
        endCallSection.style.display = 'none';
        callIdSection.style.display = 'none';

        // Hide video container (keep audio call appearance)
        videoContainer.style.display = 'none';
        videoEnabled = false;
        toggleVideoBtn.textContent = 'üìπ Enable Video';
        toggleVideoBtn.style.background = '#2196F3';

        // Clear call ID
        callIdInput.value = '';
        generatedCallId.value = '';
        currentCallId = null;

        console.log('Call ended locally and UI reset');
      } catch (error) {
        console.error('Error ending call locally:', error);
      }
    }

    // Function to toggle video on/off
    function toggleVideo() {
      try {
        if (!localStream) {
          showStatus('No active call to toggle video', true);
          return;
        }

        const videoTrack = localStream.getVideoTracks()[0];
        if (!videoTrack) {
          showStatus('Video track not available', true);
          return;
        }

        videoEnabled = !videoEnabled;

        if (videoEnabled) {
          // Enable video
          videoTrack.enabled = true;
          videoContainer.style.display = 'flex';
          toggleVideoBtn.textContent = 'üìπ Disable Video';
          toggleVideoBtn.style.background = '#FF9800';
          showStatus('Video enabled');
          console.log('Video enabled');
        } else {
          // Disable video
          videoTrack.enabled = false;
          videoContainer.style.display = 'none';
          toggleVideoBtn.textContent = 'üìπ Enable Video';
          toggleVideoBtn.style.background = '#2196F3';
          showStatus('Video disabled - Audio only mode');
          console.log('Video disabled');
        }

        // Clear status after a few seconds
        setTimeout(() => {
          hideStatus();
        }, 2000);

      } catch (error) {
        console.error('Error toggling video:', error);
        showStatus('Error toggling video', true);
      }
    }

    async function createPeerConnection(callId, isCaller) {
      try {
        pc = new RTCPeerConnection(servers);
        console.log('PeerConnection created for call:', callId, 'isCaller:', isCaller);

        // Add local tracks to peer connection
        localStream.getTracks().forEach(track => {
          console.log('Adding local track:', track.kind, track.enabled);
          pc.addTrack(track, localStream);
        });

        console.log('Local tracks added to peer connection');

        pc.ontrack = event => {
          console.log('Received remote track:', event.track.kind);
          console.log('Remote streams:', event.streams);

          const isAndroid = /Android/i.test(navigator.userAgent);

          // Handle the remote stream with Android optimizations
          if (event.streams && event.streams[0]) {
            // Use the first stream from the event
            remoteVideo.srcObject = event.streams[0];
            console.log('Remote video stream set successfully from event.streams[0]');

            // Show appropriate status based on track type
            if (event.track.kind === 'video') {
              showStatus('Remote video connected!');
            } else {
              showStatus('Remote audio connected!');
            }
          } else {
            // Fallback: create stream from individual tracks
            console.log('Creating remote stream from track');
            if (!remoteVideo.srcObject) {
              remoteVideo.srcObject = new MediaStream();
            }
            remoteVideo.srcObject.addTrack(event.track);
            console.log('Remote track added to stream');
            showStatus(`Remote ${event.track.kind} track added!`);
          }

          // Android-specific video setup for remote video
          if (isAndroid) {
            remoteVideo.setAttribute('playsinline', 'true');
            remoteVideo.setAttribute('webkit-playsinline', 'true');
            remoteVideo.setAttribute('autoplay', 'true');
            remoteVideo.setAttribute('preload', 'metadata');
          }

          // Ensure remote video plays with multiple attempts for Android
          const attemptRemotePlay = async (attempts = 3) => {
            for (let i = 0; i < attempts; i++) {
              try {
                await remoteVideo.play();
                console.log(`Remote video play successful on attempt ${i + 1}`);
                return;
              } catch (playError) {
                console.log(`Remote play attempt ${i + 1} failed:`, playError);
                if (i < attempts - 1) {
                  await new Promise(resolve => setTimeout(resolve, 300));
                }
              }
            }
            console.log('All remote play attempts failed, but continuing...');
          };

          attemptRemotePlay();
        };

        pc.onconnectionstatechange = () => {
          console.log('Connection state:', pc.connectionState);
          if (pc.connectionState === 'connected') {
            showStatus('Audio call connected successfully!');
            endCallSection.style.display = 'block'; // Show end call button
          } else if (pc.connectionState === 'failed') {
            showStatus('Connection failed. Please try again.', true);
            endCallSection.style.display = 'none'; // Hide end call button
          } else if (pc.connectionState === 'connecting') {
            showStatus('Connecting to other person...');
            endCallSection.style.display = 'none'; // Hide end call button while connecting
          } else if (pc.connectionState === 'disconnected') {
            showStatus('Call disconnected', true);
            endCallSection.style.display = 'none'; // Hide end call button
          }
        };

        pc.oniceconnectionstatechange = () => {
          console.log('ICE connection state:', pc.iceConnectionState);
          if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
            showStatus('Successfully connected to other person!');
            endCallSection.style.display = 'block'; // Show end call button
          } else if (pc.iceConnectionState === 'failed') {
            showStatus('Connection failed. Please check your internet and try again.', true);
            endCallSection.style.display = 'none'; // Hide end call button
          } else if (pc.iceConnectionState === 'checking') {
            showStatus('Checking connection...');
            endCallSection.style.display = 'none'; // Hide end call button while checking
          } else if (pc.iceConnectionState === 'disconnected') {
            showStatus('Connection lost. Trying to reconnect...', true);
            endCallSection.style.display = 'none'; // Hide end call button
          }
        };

        const callRef = ref(db, "calls/" + callId);

        pc.onicecandidate = event => {
          if (event.candidate) {
            console.log('Sending ICE candidate:', event.candidate.candidate);
            const candidateKey = Date.now() + '_' + Math.random().toString(36).substring(2, 9);
            set(ref(db, `calls/${callId}/candidates/${candidateKey}`), event.candidate.toJSON());
          } else {
            console.log('ICE gathering completed');
          }
        };

        // Set up signaling listeners
        onChildAdded(ref(db, `calls/${callId}/signals`), async snapshot => {
          const data = snapshot.val();

          // Handle end call signal
          if (snapshot.key === 'endCall' && data.type === 'endCall') {
            console.log('Received end call signal from other participant');
            showCallEndedModal();
            // End the call locally without sending another signal to avoid loop
            endCallLocally();
            return;
          }

          // Handle WebRTC signaling
          if (!data || !data.sdp) return;

          try {
            console.log('Received signal:', snapshot.key, data.sdp.type);

            if (data.sdp.type === "offer" && !isCaller) {
              // Joiner receives offer
              console.log('Joiner: Setting remote description (offer)');
              await pc.setRemoteDescription(data.sdp);
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              await set(ref(db, `calls/${callId}/signals/answer`), { sdp: pc.localDescription.toJSON() });
              console.log('Joiner: Answer sent');
              showStatus('Answer sent, waiting for connection...');
            } else if (data.sdp.type === "answer" && isCaller) {
              // Creator receives answer
              console.log('Creator: Setting remote description (answer)');
              await pc.setRemoteDescription(data.sdp);
              console.log('Creator: Answer processed');
              showStatus('Answer received, establishing connection...');
            }
          } catch (error) {
            console.error('Error handling signal:', error);
          }
        });

        // For joiners, check if there's already an offer waiting
        if (!isCaller) {
          setTimeout(async () => {
            try {
              const offerSnapshot = await get(ref(db, `calls/${callId}/signals/offer`));
              if (offerSnapshot.exists()) {
                const offerData = offerSnapshot.val();
                console.log('Joiner: Found existing offer');
                await pc.setRemoteDescription(offerData.sdp);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await set(ref(db, `calls/${callId}/signals/answer`), { sdp: pc.localDescription.toJSON() });
                console.log('Joiner: Answer sent to existing offer');
                showStatus('Connected to existing call...');
              }
            } catch (error) {
              console.error('Error checking for existing offer:', error);
            }
          }, 1000);
        }

        onChildAdded(ref(db, `calls/${callId}/candidates`), async snapshot => {
          const cand = snapshot.val();
          if (!cand) return;
          try {
            // Wait for remote description before adding candidates
            if (pc.remoteDescription) {
              await pc.addIceCandidate(cand);
              console.log('Added ICE candidate:', cand.candidate);
            } else {
              console.log('Waiting for remote description before adding candidate');
              // Store candidate to add later
              setTimeout(async () => {
                if (pc.remoteDescription) {
                  await pc.addIceCandidate(cand);
                  console.log('Added delayed ICE candidate:', cand.candidate);
                }
              }, 1000);
            }
          } catch (e) {
            console.warn('Failed to add ICE candidate:', e);
          }
        });

        if (isCaller) {
          // Small delay to ensure all listeners are set up
          setTimeout(async () => {
            try {
              console.log('Creator: Creating and sending offer...');
              const offer = await pc.createOffer();
              await pc.setLocalDescription(offer);
              await set(ref(db, `calls/${callId}/signals/offer`), { sdp: pc.localDescription.toJSON() });
              console.log('Creator: Offer created and sent to Firebase');
              showStatus('Waiting for other person to join...');
            } catch (error) {
              console.error('Error creating offer:', error);
              showStatus('Error creating call. Please try again.', true);
            }
          }, 500);
        } else {
          console.log('Joiner: Waiting for offer...');
          showStatus('Connecting to call...');
        }
      } catch (error) {
        console.error('Error creating peer connection:', error);
        alert('Error setting up connection. Please try again.');
      }
    }

    // Button event handlers
    createBtn.onclick = async () => {
      try {
        // Show permission help first
        document.getElementById('permissionHelp').style.display = 'block';

        showStatus("Click 'Allow' when prompted for camera/microphone access...");
        await initMedia();

        // CRITICAL: Ensure local video is visible IMMEDIATELY for creator
        console.log('Creator: Setting local video immediately after initMedia');
        localVideo.srcObject = localStream;
        await localVideo.play();
        console.log('Creator: Local video should be visible now');

        // Debug check
        setTimeout(() => checkVideoStatus(), 1000);

        currentCallId = generateCallId();
        generatedCallId.value = currentCallId;
        callIdSection.style.display = 'block';

        showStatus("Creating call...");
        await createPeerConnection(currentCallId, true);

        showStatus(`Call created! Share the Call ID: ${currentCallId}`);
        console.log('Call created with ID:', currentCallId);

        // Hide permission help once successful
        document.getElementById('permissionHelp').style.display = 'none';
      } catch (error) {
        console.error('Error creating call:', error);
        showStatus("Error creating call. Please allow camera/microphone access and try again.", true);
      }
    };

    joinBtn.onclick = async () => {
      try {
        const callId = callIdInput.value.trim().toUpperCase();
        if (!callId) {
          showStatus("Please enter a Call ID", true);
          return;
        }

        // Show permission help first
        document.getElementById('permissionHelp').style.display = 'block';

        showStatus("Click 'Allow' when prompted for camera/microphone access...");
        await initMedia();

        // CRITICAL: Ensure local video is visible IMMEDIATELY for joiner
        console.log('Joiner: Setting local video immediately after initMedia');
        localVideo.srcObject = localStream;
        await localVideo.play();
        console.log('Joiner: Local video should be visible now');

        // Debug check
        setTimeout(() => checkVideoStatus(), 1000);

        showStatus("Joining call...");
        currentCallId = callId;
        await createPeerConnection(callId, false);

        showStatus(`Joined call: ${callId}`);
        console.log('Joined call with ID:', callId);

        // Hide permission help once successful
        document.getElementById('permissionHelp').style.display = 'none';
      } catch (error) {
        console.error('Error joining call:', error);
        showStatus('Error joining call. Please allow camera/microphone access and try again.', true);
      }
    };

    // Copy Call ID functionality
    copyCallIdBtn.onclick = async () => {
      try {
        await navigator.clipboard.writeText(currentCallId);
        showStatus("Call ID copied to clipboard!");
        setTimeout(hideStatus, 2000);
      } catch (error) {
        console.error('Error copying to clipboard:', error);
        // Fallback: select the text
        generatedCallId.select();
        generatedCallId.setSelectionRange(0, 99999);
        showStatus("Call ID selected. Press Ctrl+C to copy.");
      }
    };

    // End Call functionality
    endCallBtn.onclick = () => {
      if (confirm('Are you sure you want to end the call?')) {
        endCall();
      }
    };

    // Toggle Video functionality
    toggleVideoBtn.onclick = () => {
      toggleVideo();
    };

    // Request Permissions functionality
    document.getElementById('requestPermissionsBtn').onclick = () => {
      requestPermissionsManually();
    };
  </script>
</body>

</html>
<!-- added -->